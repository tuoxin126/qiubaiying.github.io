---
layout:     post
title:     Java 操作Kafka 示例
subtitle:   Kafka
date:       2019-02-25
author:     BY tuo
header-img: img/post-bg-centos-web.jpg
catalog: 	 true
tags:
    - LeetCode练习题
---
### 单线程操作
Maven 配置

  		<!-- https://mvnrepository.com/artifact/org.apache.kafka/kafka-clients -->
		<dependency>
			<groupId>org.apache.kafka</groupId>
			<artifactId>kafka-clients</artifactId>
			<version>2.1.1</version>
		</dependency>
生产者代码：
```
import java.util.Properties;

import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerRecord;

public class ProducerDemo2 {
	public static void main(String[] args) {
		Properties props = new Properties();
		// kafka的地址
		props.put("bootstrap.servers",
				"synhadoop100:9092,synhadoop101:9092,synhadoop102:9092,synhadoop103:9092,synhadoop104:9092");
		// acks:消息的确认机制，默认值是0
		// acks=0：如果设置为0，生产者不会等待kafka的响应。
		// acks=1：这个配置意味着kafka会把这条消息写到本地日志文件中，但是不会等待集群中其他机器的成功响应
		// acks=all：这个配置意味着leader会等待所有的follower同步完成。这个确保消息不会丢失，除非kafka集群中所有机器挂掉。这是最强的可用性保证
		props.put("acks", "all");
		// 配置为大于0的值的话，客户端会在消息发送失败时重新发送
		props.put("retries", 0);
		// 当多条消息需要发送到同一个分区时，生产者会尝试合并网络请求。这会提高client和生产者的效率。
		props.put("batch.size", 16384);
		// 在正常负载的情况下, 要想减少请求的数量. 加上一个认为的延迟: 不是立即发送消息, 而是延迟等待更多的消息一起批量发送. 类似TCP中的Nagle算法.
		// 当获得了batch.size的同一partition的消息会立即发送, 不管linger.ms的设置. 假如要发送的消息比较少,
		// 会等待指定的时间以获取更多的消息.
		props.put("linger.ms", 1000);
		// producer可以使用的最大内存来缓存等待发送到server端的消息.
		props.put("buffer.memory", 33554432);
		// 键序列化，默认org.apache.kafka.common.serialization.StringDeserializer
		props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
		// 值序列化，默认org.apache.kafka.common.serialization.StringDeserializer
		props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");
    
    // 主题
		String topic = "test";
		Producer<String, String> producer = new KafkaProducer<>(props);
		for (int i = 0; i < 100; i++) {
			producer.send(new ProducerRecord<String, String>(topic, Integer.toString(i), Integer.toString(i)));
		}
		producer.close();
	}
}

```
